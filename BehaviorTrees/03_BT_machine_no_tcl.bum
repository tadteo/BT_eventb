<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.machineFile org.eventb.core.configuration="org.eventb.core.fwd" org.eventb.core.generated="false" org.eventb.texttools.text_lastmodified="1656424437577" org.eventb.texttools.text_representation="machine 03_BT_machine refines 02_tree_machine  sees 02_tree_context&#10;&#10;variables n_tick analyzing_subtree n_result&#10;&#10;invariants&#10;  @inv1 ⊤ // children_unticked ∈ nodes → ℙ(nodes)&#10;  @inv2 ⊤ // to identify the children_unticked I just used the set of all the children (parent~[{node}]) which has tick equal to true&#10;  @inv3 ∀n·(n ∈ parent∼[{n}] ∧ n_result(n) ≠ UNKNOWN ⇔ n_tick(n) = TRUE) // to be revised&#10;  @inv4 ∀n,n1,n2·(n1 ∈ parent∼[{n}] ∧ n2 ∈ parent∼[{n}] ∧ n_tick(n1)=TRUE ∧ n_result(n1) = UNKNOWN ⇒ n_tick(n2) = FALSE ∧ n_result(n2) = UNKNOWN) // to be revised&#10;  @inv5 n_tick ∈ NODES → BOOL&#10;  @inv8 n_result ∈ NODES → RESULT&#10;  @inv6 analyzing_subtree ∈ NODES → BOOL&#10;  @inv7 children_unticked = ∀x·(x∈nodes ∧ x ↦ {n ∣ n ∈ parent∼[{x}] n_tick(parent∼[{x}] ) = FALSE})&#10;&#10;events&#10;&#10;  event INITIALISATION&#10;    then&#10;      @act2 n_tick ≔ NODES × {FALSE}&#10;      @act5 n_result ≔ NODES × {UNKNOWN}&#10;      @act3 analyzing_subtree ≔ NODES × {FALSE}&#10;  end&#10;&#10;  event condition_ticked&#10;    any node&#10;    where&#10;      @grd1 n_tick(node) = TRUE&#10;      theorem @grd2 n_type(node) = CONDITION&#10;      @grd3 node ∈ nodes&#10;    then&#10;      @act1 n_result(node) :∈ {SUCCESS, FAILURE}&#10;      @act2 analyzing_subtree(parent(node)) ≔ FALSE&#10;  end&#10;&#10;  event action_ticked&#10;    any node&#10;    where&#10;      @grd1 n_tick(node) = TRUE&#10;      @grd3 node ∈ nodes&#10;      @grd2 n_type(node) = ACTION&#10;    then&#10;      @act1 n_result :∈ {SUCCESS, FAILURE, RUNNING}&#10;      @act2 analyzing_subtree(parent(node)) ≔ FALSE&#10;  end&#10;&#10;  event sequence_ticked_continue&#10;    any node child&#10;    where&#10;      @grd1 n_type(node) = SEQUENCE&#10;      @grd2 n_tick(node) = TRUE&#10;      @grd3 n_result(node) = UNKNOWN&#10;      @grd4 ∃x · (x ∈  parent∼[{node}] ∧ n_tick(x) = TRUE ∧&#10;            ∀y·(y∈parent∼[{node}] ∧ n_tick(y) = TRUE ∧ n_id(y)&lt;n_id(x))&#10;            ∧ n_result(x) = SUCCESS) // if exist a child  which is ticked and its id is the maximum of the ticked child and is status is SUCCESS is means that the previous child status is SUCCES&#10;      @grd5 {x ∣ x ∈  parent∼[{node}] ∧ n_tick(x) = FALSE}= ∅&#10;      theorem @grd6 node ∈ nodes&#10;      @grd7 child ∈ {x ∣ x ∈  parent∼[{node}] ∧ n_tick(x) = FALSE ∧&#10;            ∀y·(y∈parent∼[{node}] ∧ n_tick(y) = FALSE ∧ n_id(y)&gt;n_id(x))}&#10;      /* the next child to analyze is the child node&#10;         which has the smallest id of the&#10;         children that have not been ticked yet */&#10;      theorem @grd8 analyzing_subtree(node) = FALSE&#10;    then&#10;      @act1 n_tick(child) ≔ TRUE&#10;      @act3 analyzing_subtree(node) ≔ TRUE&#10;  end&#10;&#10;  event sequence_ticked_failure&#10;    any node&#10;    where&#10;      @grd1 n_type(node) = SEQUENCE&#10;      @grd2 n_tick(node) = TRUE&#10;      @grd3 n_result(node) = UNKNOWN&#10;      @grd4 ∃x · (x ∈  parent∼[{node}] ∧ n_tick(x) = TRUE ∧&#10;            ∀y·(y∈parent∼[{node}] ∧ n_tick(y) = TRUE ∧ n_id(y)&lt;n_id(x))&#10;            ∧ n_result(x) = FAILURE) // previous_child_status =  FAILURE&#10;      @grd5 node ∈ nodes&#10;    then&#10;      @act1 n_result(node) ≔ FAILURE&#10;      @act2 analyzing_subtree(parent(node)) ≔ FALSE&#10;  end&#10;&#10;  event sequence_ticked_running&#10;    any node&#10;    where&#10;      @grd1 n_type(node) = SEQUENCE&#10;      @grd2 n_tick(node) = TRUE&#10;      @grd3 n_result(node) = UNKNOWN&#10;      @grd4 ∃x · (x ∈  parent∼[{node}] ∧ n_tick(x) = TRUE ∧&#10;            ∀y·(y∈parent∼[{node}] ∧ n_tick(y) = TRUE ∧ n_id(y)&lt;n_id(x))&#10;            ∧ n_result(x) = RUNNING) // previous_child_status =  RUNNING&#10;      @grd5 node ∈ nodes&#10;    then&#10;      @act1 n_result(node) ≔ RUNNING&#10;      @act2 analyzing_subtree(parent(node)) ≔ FALSE&#10;  end&#10;&#10;  event sequence_ticked_success&#10;    any node&#10;    where&#10;      @grd1 n_type(node) = SEQUENCE&#10;      @grd2 n_tick(node) = TRUE&#10;      @grd3 n_result(node) = UNKNOWN&#10;      @grd4 ∃x · (x ∈  parent∼[{node}] ∧ n_tick(x) = TRUE ∧&#10;            ∀y·(y∈parent∼[{node}] ∧ n_tick(y) = TRUE ∧ n_id(y)&lt;n_id(x))&#10;            ∧ n_result(x) = SUCCESS) // previous_child_status =  SUCCESS&#10;      @grd5 {x ∣ x ∈  parent∼[{node}] ∧ n_tick(x) = FALSE}= ∅ // the unticked children of the node is an empty set&#10;      @grd6 node ∈ nodes&#10;    then&#10;      @act1 n_result(node) ≔ SUCCESS&#10;      @act2 analyzing_subtree(parent(node)) ≔ FALSE&#10;  end&#10;&#10;  event fallback_ticked_running&#10;    any node&#10;    where&#10;      @grd1 n_type(node) = FALLBACK&#10;      @grd2 n_tick(node) = TRUE&#10;      @grd3 n_result(node) = UNKNOWN&#10;      @grd4 ∃x · (x ∈  parent∼[{node}] ∧ n_tick(x) = TRUE ∧&#10;            ∀y·(y∈parent∼[{node}] ∧ n_tick(y) = TRUE ∧ n_id(y)&lt;n_id(x))&#10;            ∧ n_result(x) = RUNNING) // previous_child_status =  RUNNING&#10;      @grd5 node ∈ nodes&#10;    then&#10;      @act1 n_result(node) ≔ RUNNING&#10;      @act2 analyzing_subtree(parent(node)) ≔ FALSE&#10;  end&#10;&#10;  event fallback_ticked_continue&#10;    any node child&#10;    where&#10;      @grd1 n_type(node) = FALLBACK&#10;      @grd2 n_tick(node) = TRUE&#10;      @grd3 n_result(node) = UNKNOWN&#10;      @grd4 ∃x · (x ∈  parent∼[{node}] ∧ n_tick(x) = TRUE ∧&#10;            ∀y·(y∈parent∼[{node}] ∧ n_tick(y) = TRUE ∧ n_id(y)&lt;n_id(x))&#10;            ∧ n_result(x) = FAILURE) // previous_child_status =  FAILURE&#10;      theorem @grd5 children_unticked(node) ≠ ∅&#10;      @grd6 node ∈ nodes&#10;      @grd7 child ∈ {x ∣ x ∈  parent∼[{node}] ∧ n_tick(x) = FALSE ∧&#10;            ∀y·(y∈parent∼[{node}] ∧ n_tick(y) = FALSE ∧ n_id(y)&gt;n_id(x))}&#10;      @grd8 analyzing_subtree(node) = FALSE&#10;    then&#10;      @act2 n_tick(child) ≔ TRUE&#10;      @act3 analyzing_subtree(node) ≔ TRUE&#10;  end&#10;&#10;  event fallback_ticked_failure&#10;    any node&#10;    where&#10;      @grd1 n_type(node) = FALLBACK&#10;      @grd2 n_tick(node) = TRUE&#10;      @grd3 n_result(node) = UNKNOWN&#10;      @grd4 ∃x · (x ∈  parent∼[{node}] ∧ n_tick(x) = TRUE ∧&#10;            ∀y·(y∈parent∼[{node}] ∧ n_tick(y) = TRUE ∧ n_id(y)&lt;n_id(x))&#10;            ∧ n_result(x) = FAILURE) // previous_child_status =  FAILURE&#10;      @grd5 {x ∣ x ∈  parent∼[{node}] ∧ n_tick(x) = FALSE}= ∅&#10;      @grd6 node ∈ nodes&#10;    then&#10;      @act1 n_result(node) ≔ FAILURE&#10;      @act2 analyzing_subtree(parent(node)) ≔ FALSE&#10;  end&#10;&#10;  event fallback_ticked_success&#10;    any node&#10;    where&#10;      @grd1 n_type(node) = FALLBACK&#10;      @grd2 n_tick(node) = TRUE&#10;      @grd3 n_result(node) = UNKNOWN&#10;      @grd4 ∃x · (x ∈  parent∼[{node}] ∧ n_tick(x) = TRUE ∧&#10;            ∀y·(y∈parent∼[{node}] ∧ n_tick(y) = TRUE ∧ n_id(y)&lt;n_id(x))&#10;            ∧ n_result(x) = SUCCESS) // previous_child_status =  SUCCESS&#10;      @grd5 node ∈ nodes&#10;    then&#10;      @act1 n_result(node) ≔ SUCCESS&#10;      @act2 analyzing_subtree(parent(node)) ≔ FALSE&#10;  end&#10;&#10;  event root_ticked&#10;    any node child&#10;    where&#10;      @grd1 n_tick(node) = TRUE&#10;      @grd2 n_type(node) = ROOT&#10;      @grd3 n_tick(child) = FALSE&#10;      @grd4 node ∈ children_unticked(node)&#10;      @grd5 child ∈ NODES&#10;    then&#10;      @act1 n_tick(child) ≔ TRUE&#10;      @act2 analyzing_subtree(node) ≔ TRUE&#10;  end&#10;&#10;  event result_arrived&#10;    any node&#10;    where&#10;      @grd1 n_type(node) = ROOT&#10;      @grd2 n_result(node) ≠ UNKNOWN&#10;    then&#10;      @act1 ∀n·(n∈nodes ⇒ n_tick(n) = FALSE ∧ n_result = UNKNOWN)&#10;  end&#10;end&#10;" version="5">
    <org.eventb.core.refinesMachine name="_08zpV_bDEeyQiudq0A8KL'" org.eventb.core.target="02_tree_machine_no_tcl"/>
    <org.eventb.core.seesContext name="_08zpV_bDEeyQiudq0A8KKx" org.eventb.core.target="03_BT_context_no_tcl"/>
    <org.eventb.core.event name="'" org.eventb.core.convergence="0" org.eventb.core.extended="false" org.eventb.core.generated="false" org.eventb.core.label="INITIALISATION">
        <org.eventb.core.action name="_08v-4PbDEeyQiudq0A8KKx" org.eventb.core.assignment="n_tick ≔ NODES × {FALSE}" org.eventb.core.generated="false" org.eventb.core.label="act2"/>
        <org.eventb.core.action name="_08v-4PbDEeyQiudq0A8KK{" org.eventb.core.assignment="n_result ≔ NODES × {UNKNOWN}" org.eventb.core.generated="false" org.eventb.core.label="act5"/>
        <org.eventb.core.action name="_08v-4PbDEeyQiudq0A8KKy" org.eventb.core.assignment="analyzing_subtree ≔ NODES × {FALSE}" org.eventb.core.generated="false" org.eventb.core.label="act3"/>
    </org.eventb.core.event>
    <org.eventb.core.invariant name="_08zpV_bDEeyQiudq0A8KK{" org.eventb.core.comment="children_unticked ∈ nodes → ℙ(nodes)" org.eventb.core.generated="false" org.eventb.core.label="inv1" org.eventb.core.predicate="⊤"/>
    <org.eventb.core.invariant name="_08zpV_bDEeyQiudq0A8KK|" org.eventb.core.comment="to identify the children_unticked I just used the set of all the children (parent~[{node}]) which has tick equal to true" org.eventb.core.generated="false" org.eventb.core.label="inv2" org.eventb.core.predicate="⊤"/>
    <org.eventb.core.invariant name="_08zpV_bDEeyQiudq0A8KK~" org.eventb.core.comment="to be revised" org.eventb.core.generated="false" org.eventb.core.label="inv4" org.eventb.core.predicate="∀n,n1,n2·(n∈NODES ∧ n1 ∈ parent∼[{n}] ∧ n2 ∈ parent∼[{n}] ∧ n1 ≠ n2 ∧ n_tick(n1)=TRUE ∧ n_result(n1) = UNKNOWN ⇒ n_tick(n2) = FALSE ∧ n_result(n2) = UNKNOWN)"/>
    <org.eventb.core.variable name="_08zpV_bDEeyQiudq0A8KL(" org.eventb.core.generated="false" org.eventb.core.identifier="n_tick"/>
    <org.eventb.core.variable name="_08zpV_bDEeyQiudq0A8KL-" org.eventb.core.generated="false" org.eventb.core.identifier="n_result"/>
    <org.eventb.core.invariant name="_08zpV_bDEeyQiudq0A8KL/" org.eventb.core.comment="For each couple of children of a sequence node &#10;two siblings are ticked if and only if one of the two is success&#10;∀n1,n2,s·(s∈nodes ∧ n_type(s) = SEQUENCE ∧ n1 ∈ parent∼[{s}]  ∧ n2 ∈ parent∼[{s}] ∧ n_tick(n1) = TRUE ∧ n_tick(n2) = TRUE ⇔ (n_result(n1) = SUCCESS ∨ n_result(n2) = SUCCESS))" org.eventb.core.label="inv9" org.eventb.core.predicate="⊤" org.eventb.core.theorem="true"/>
    <org.eventb.core.invariant name="_08zpV_bDEeyQiudq0A8KL0" org.eventb.core.comment="For each couple of children of a fallback node &#10;two siblings are ticked if and only if one of the &#10;two is failed&#10;∀n1,n2,s·(s∈nodes∧ n_type(s) = FALLBACK ∧ n1 ∈ parent∼[{s}]  ∧ n2 ∈ parent∼[{s}]  ∧ n_tick(n1) = TRUE ∧ n_tick(n2) = TRUE ⇔ (n_result(n1) = FAILURE ∨ n_result(n2) = FAILURE))" org.eventb.core.label="inv10" org.eventb.core.predicate="⊤ "/>
    <org.eventb.core.variable name="_08zpV_bDEeyQiudq0A8KL4" org.eventb.core.identifier="analyzing_subtree"/>
</org.eventb.core.machineFile>
